## 分片
Redis 的分片承担着两个主要目标
- 允许使用很多电脑的内存总和来支持更大的数据库。没有分片，你就被局限于单机能支持的内存容量。
- 允许伸缩计算能力到多核或多服务器，伸缩网络带宽到多服务器或多网络适配器
### 分片策略
- range partitioning(范围分片)

    通过映射对象的范围到指定的 Redis 实例来完成分片。例如，ID 0到10000 进入实例 R0，ID 10001到20000 进入实例 R1，
    但是有明显的缺点，就是需要一个映射范围到实例的表，所以范围分片在 Redis 中常常并不可取
- hash partitioning(哈希分片)

    哈希分片，对key进行hash，然后对结果取模映射到对应的机器上
- consistent hashing partitioning(一致性哈希分片)

    一致性hash是对hash的优化，[一致性hash详细介绍](/markdown/java/hash.md)
### 分片实现方式

- 客户端分片(Client side partitioning) 

    客户端直接选择正确的节点来写入和读取指定键。许多 Redis 客户端实现了客户端分片
- 代理协助分片(Proxy assisted partitioning)
    
    我们的客户端发送请求到一个可以理解 Redis 协议的代理上，而不是直接发送请求到 Redis 实例上。代理会根据配置好的分片模式，来保证转发我们的请求到正确的 Redis 实例，并返回响应给客户端。Redis 和 Memcached 的代理 Twemproxy 实现了代理协助的分片
- 查询路由(Query routing)

    送你的查询到一个随机实例，这个实例会保证转发你的查询到正确的节点。Redis 集群在客户端的帮助下，实现了查询路由的一种混合形式 (请求不是直接从 Redis 实例转发到另一个，而是客户端收到重定向到正确的节点)
### 分片的缺点

- 涉及多个键的操作通常不支持

    例如，你不能对映射在两个不同 Redis 实例上的键执行交集(事实上有办法做到，但不是直接这么干)
- 涉及多个键的事务不能使用

    分片的粒度(granularity)是键，所以不能使用一个很大的键来分片数据集，例如一个很大的有序集合
- 当使用了分片，数据处理变得更复杂

    例如，你需要处理多个 RDB/AOF 文件，备份数据时你需要聚合多个实例和主机的持久化文件。
- 添加和删除容量也很复杂。
    
    例如，Redis 集群具有运行时动态添加和删除节点的能力来支持透明地再均衡数据，但是其他方式，像客户端分片和代理都不支持这个特性。
    
### 预分片(Presharding)   

一开始就开启很多的实例。即使你一开始只有一台服务器，你也可以在第一天就决定生活在分布式的世界里，使用分片来运行多个 Redis 实例在一台服务器上。

当你的数据存储需要增长，你需要更多的 Redis 服务器，你要做的就是简单地将实例从一台服务器移动到另外一台。当你新添加了第一台服务器，你就需要把一半的 Redis 实例从第一台服务器搬到第二台，如此等等。

使用 Redis 复制，你就可以在很小或者根本不需要停机时间内完成移动数据：

- 在你的新服务器上启动一个空实例。
- 移动数据，配置新实例为源实例的从服务。
- 停止你的客户端。
- 更新被移动实例的服务器 IP 地址配置。
- 向新服务器上的从节点发送 SLAVEOF NO ONE 命令。
- 以新的更新配置启动你的客户端。
- 最后关闭掉旧服务器上不再使用的实例。
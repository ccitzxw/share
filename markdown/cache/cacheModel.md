# 缓存实战
---
## 一 热key
通常使用 缓存 + 过期时间的策略来帮助我们加速接口的访问速度，减少了后端负载，同时保证功能的更新，一般情况下这种模式已经基本满足要求了。但是无法避免热key的问题
### 1.1 热key失效 
由于一些突发的的事件，导致某新闻点击量瞬间变大，请求远超过对数据的写入。就会造成热数据问题。热点key缓存失效瞬间可能造成[缓存击穿](/markdown/cache/cache.md)问题 
### 1.2 解决方案
#### 1.2.1 使用互斥锁
在上图查询数据库的过程，只让一个线程独占，这个线程构建缓存的过程，其他线程都要等待，直到第一个线程构建完成可以从中读取数据
#### 1.2.2 提前使用互斥锁
提前使用互斥锁，和互斥锁差不多，都是让一个线程独占构建缓存，不一样的是，在构建缓存的时候。在value内部设置一个超时值timeout1，这个过期时间比实际的缓存过期时间短。
当从缓存中读到timeout1已经过期的时候，就认为数据也快过期了，直接执行查询数据库，进行构建缓存的过程。这样在所有快过期的数据前，就重新构建了缓存
#### 1.2.3 使用本地缓存
热key问题需要对重建缓存过程进行限制，避免多个线程同时重建缓存。使用本地缓存[guava的阻塞加载机制](/markdown/cache/guava.md) 可以避免热key问题

## 二 秒杀

## 三 分布式缓存锁

## 四 缓存的事物

## 五 三级缓存模型
![三级缓存模型](../../picture/cache/三级缓存结构.PNG)
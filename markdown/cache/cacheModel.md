# 缓存实战
---
## 一 分布式缓存锁
### 1.1 基于setnx实现
redis没有像mysql中的排它锁，但是可以通过一些方式实现排它锁的功能，setnx实现了exists和set两个指令的功能，若给定的key已存在，则setnx不做任何动作，返回0；若key不存在，则执行类似set的操作，返回1。
### 1.2 基于zookeeper临时顺序节点实现
#### 1.2.1 临时顺序节点(EPHEMERAL_SEQUENTIAL)
EPHEMERAL_SEQUENTIAL由某个客户端创建，当客户端与ZooKeeper集群断开连接，则开节点自动被删除。假如我们在/lock/目录下创建节3个点，ZooKeeper集群会按照提起创建的顺序来创建节点，节点分别为/lock/0000000001、/lock/0000000002、/lock/0000000003。
基于临时顺序节点的机制和在节点上注册上子节点变更通知的Watcher实现锁机制
#### 1.2.2 锁机制创建过程
客户端调用create()方法创建名为“locknode/guid-lock-”的节点，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。<br>
客户端调用getChildren(“locknode”)方法来获取所有已经创建的子节点，同时在这个节点上注册上子节点变更通知的Watcher。<br>
客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，那么就认为这个客户端获得了锁。<br>
如果在步骤3中发现自己并非是所有子节点中最小的，说明自己还没有获取到锁，就开始等待，直到下次子节点变更通知的时候，再进行子节点的获取，判断是否获取锁
#### 1.2.3 利用临时顺序节点实现共享锁的改进实现
对于加锁操作，可以让所有客户端都去/lock目录下创建临时顺序节点，如果创建的客户端发现自身创建节点序列号是/lock/目录下最小的节点，则获得锁。否则，监视比自己创建节点的序列号小的节点（比自己创建的节点小的最大节点），进入等待

## 二 热key
通常使用 缓存 + 过期时间的策略来帮助我们加速接口的访问速度，减少了后端负载，同时保证功能的更新，一般情况下这种模式已经基本满足要求了。但是无法避免热key的问题
### 2.1 热key失效 
由于一些突发的的事件，导致某新闻点击量瞬间变大，请求远超过对数据的写入。就会造成热数据问题。热点key缓存失效瞬间可能造成[缓存击穿](/markdown/cache/cache.md)问题 
### 2.2 解决方案
#### 2.2.1 使用互斥锁
在上图查询数据库的过程，只让一个线程独占，这个线程构建缓存的过程，其他线程都要等待，直到第一个线程构建完成可以从中读取数据
#### 2.2.2 提前使用互斥锁
提前使用互斥锁，和互斥锁差不多，都是让一个线程独占构建缓存，不一样的是，在构建缓存的时候。在value内部设置一个超时值timeout1，这个过期时间比实际的缓存过期时间短。
当从缓存中读到timeout1已经过期的时候，就认为数据也快过期了，直接执行查询数据库，进行构建缓存的过程。这样在所有快过期的数据前，就重新构建了缓存
#### 2.2.3 使用本地缓存
热key问题需要对重建缓存过程进行限制，避免多个线程同时重建缓存。使用本地缓存[guava的阻塞加载机制](/markdown/cache/guava.md) 可以避免热key问题

## 三 秒杀
### 3.1 基于redis的list
基于队列的方案利用了redis出队操作的原子性，抢购开始之前首先将商品编号放入响应的队列中，在抢购时依次从队列中弹出操作，这样可以保证每个商品只能被一个进程获取并操作，不存在超发的情况。该方案的优点是理解和实现起来都比较简单，缺点是当商品数量较多是，需要将大量的数据存入到队列中，并且不同的商品需要存入到不同的消息队列中
### 3.2 基于redis的decr
如果我们将剩余量num设置为一个键值类型，每次先get之后判断，然后再decr是不能解决超发问题的。但是redis中的decr操作会返回执行后的结果，可以解决超发问题。我们首先get到num的值进行第一步判断，避免每次都去更新num的值，然后再对num执行decr操作，并判断decr的返回值，如果返回值不小于0，这说明decr之前是大于0的，用户抢购成功
### 3.3 基于setnx的排它锁方案
我们设置一个超时时间timeout，每隔一定时间尝试setnx操作，如果设置成功就是获得了相应的锁，执行num的decr操作，操作完成删除相应的key，模拟释放锁的操作。

## 四 三级缓存模型
![三级缓存模型](../../picture/cache/三级缓存结构.PNG)